#!/usr/bin/env python3
import re
import youtube_dl
import subprocess
import time
import os

# seconds
RIGHT_PAD = 0.4
LEFT_PAD = 0.0

class Interval:
    def __init__(self, start_time, end_time, match_string):
        """
        start_time and end_time should be strings hh:mm:ss[.xxx]
        match_string is the string that the Interval matches
        """
        self.start_time = start_time
        self.end_time = end_time
        self.match_string = match_string

    def __repr__(self):
        return f"Interval({self.start_time}, {self.end_time}, {self.match_string})"

TIMESTAMP_REGEX = r'\d+:\d{2}:\d{2}\.\d{3}'
TIME_WORD_1_REGEX = rf"(?P<time1>{TIMESTAMP_REGEX}) --> .*\n.*\n(?P<word1>[^<\n]+)(?=<)"
TIME_WORD_2_REGEX = rf"<(?P<time2>{TIMESTAMP_REGEX})><c> (?P<word2>[^<]+)</c>"
TIME_WORD_REGEX = re.compile(rf"{TIME_WORD_1_REGEX}|{TIME_WORD_2_REGEX}")
FINAL_TIME_REGEX = re.compile(rf"--> (?P<time>{TIMESTAMP_REGEX})")
def get_time_intervals(regex, subtitle):
    """
    Get the time intervals of all phrases that match `regex` in the space-separated words of `subtitle`.

    Returns a iterator of `Interval`s times in the format hh:mm:ss.000

    Only tested to work for autogenerated subtitles in VTT format from YouTube's autogeneration.
    """
    # module webvtt only gets the line-captions, not individual words, so it's time for some regex!
    # The time corresponding to a word is when that word *starts*
    # words = (match.group("word") for match in WORD_REGEX.finditer(subtitle))
    time_words = [
        (m.group("time1") or m.group("time2"), m.group("word1") or m.group("word2"))
        for m in TIME_WORD_REGEX.finditer(subtitle)
    ]
    # Incorrect format, which would lead to trouble zipping
    if len(time_words) == 0:
        return []
    times, words = zip(*time_words)
    # Quickly search lines starting from the end
    final_time = next(match.group("time") for line in reversed(subtitle.split("\n")) for match in [re.search(FINAL_TIME_REGEX, line)] if match)
    # timestamps[i] is the time the word starts at if i is the index of the start of a word
    timestamps = {}
    # Build search_str while computing time_stamps by adding one word and one space at a time
    search_str = ''
    words = list(words)
    for word, time in zip(words, times):
        timestamps[len(search_str)] = time
        search_str += word + ' '
    timestamps[len(search_str)] = final_time
    # Trim off the final space
    # Inconsistent capitalization, so just lowercase
    search_str = search_str[:-1].lower()
    for match in re.finditer(regex, search_str):
        start, end = match.span()
        yield Interval(
            timestamps[max(i for i in timestamps if i<=start)],
            timestamps[min(i for i in timestamps if i>end)],
            match.group(0)
        )

def subtitle_filename(video_id):
    return f"subtitles/{video_id}.en.vtt"

def download_subtitles(video_ids):
    ydl_opts = {
        'skip_download': True,
        'writeautomaticsub': True,
        'outtmpl': 'subtitles/%(id)s',
        'subtitleslangs': ['en']
    }
    for video_id in video_ids:
        filename = subtitle_filename(video_id)
        # Don't download if these subtitles are already downloaded
        if not os.path.isfile(filename):
            with youtube_dl.YoutubeDL(ydl_opts) as ydl:
                # assume downloaded subtitle is correct
                ydl.download([video_id])
                # Delay to be nice to the server
                time.sleep(2)
        try:
            with open(filename) as f:
                yield video_id, f.read()
        except IOError:
            yield video_id, ""

def parse_time(time):
    h,m,s = [float(t) for t in time.split(":")]
    return 3600*h+60*m+s

def download_intervals(video_id, intervals):
    for i in intervals:
        start = parse_time(i.start_time)
        end = parse_time(i.end_time)
        start = start - LEFT_PAD
        duration = end - start + RIGHT_PAD
        sanitized_match_string = re.sub('[^a-zA-Z0-9_-]', '_', i.match_string)
        filename = f"clips/{sanitized_match_string}+{video_id}+{i.start_time}.mp4"
        if not os.path.isfile(filename):
            subprocess.run(['bash', 'download_clip.bash', video_id, str(start), str(duration), filename])
            # Delay between video downloads to respect the server
            time.sleep(2)

def download_clips(video_ids, regex=None, dry=False, limit=1):
    """
    Pass dry=True to not download any clips
    Pass regex=None to additionally not even determine the intervals
    In all cases, subtitles will be downloaded
    """
    # extract just first 11 character id in case something longer is passed
    video_ids = [video_id[:11] for video_id in video_ids]
    num_remaining = limit
    for i, (video_id, subtitle) in enumerate(download_subtitles(video_ids)):
        print(f"[info] considering video {i+1}/{len(video_ids)}: {video_id}")
        if not regex:
            print("[info] subtitles done; continuing")
            continue
        if not subtitle:
            print(f"WARNING: {video_id} lacks automatic captions")
            continue
        intervals = list(get_time_intervals(regex, subtitle))
        intervals = intervals[:num_remaining] if num_remaining > 0 else intervals
        print(f"[info] downloading {len(intervals)} interval{'s'[:len(intervals)!=1]}")
        if dry:
            print("[intervals]", intervals)
        else:
            download_intervals(video_id, intervals)
        num_remaining -= len(intervals)
        if num_remaining == 0:
            break

# Down to ~800
videos = ["_Fz1pO7nI50", "5pGepIfFxzQ", "bIC0x8OSNzg", "d-hBDjYtE1U", "Pa6VWW7zYJw", "qYbNxE_SEIk", "81gXBVKF19o", "nOqDkdekaVE", "qvacFG9GyOM", "8b9y8QvxenU", "H6MuZhzqKGA", "avwt39uHDOQ", "oFktnCdbavA", "pTys_WYBOLE", "1lLiDnFTsOk", "D1ejvQ0UUNY", "vn0xMtHhgSQ", "JDNoMbjxBMI", "94z0OJ_-4Lo", "vMulHvAznwM", "D0foSHWP7rc&t=5s", "EdD5oS5yaqg", "o6lteqXZdrA", "26OYMHIhK2U", "aY36o7JY4bo", "DvkSYh2dkN8", "WqE3leevbdg", "lF0uiRS8asc", "pLUGPqw0oks", "ZpX2b2t00Lg", "soyWGLnzeeI", "Gl7gt0SeBi8", "uPqwp7TPGzQ", "-d760fMfiNc", "mG9RHjC9rTM", "uukkzSy3Aw8", "EA5wr3qTVOc", "YzncNl6N18s", "c2DcfJLquOk", "J5Kxm8I1BXU", "mjArO09tGaI", "_iEP_uKOdrQ", "ZW3s1iks0No", "8WkNoA_ki9c", "njU3r3aWm3k", "ixPFDFp8Cfo", "nk6KrBsDwDE", "-aOh4D2GKaw", "TTcrdX7dIZ8", "v_IPY3MM3Yc", "lkfBKQuLkRc", "Cw0EPb3S8v4", "APvmp-rp_D0", "Csa01fsnCQE", "K2KNc4g-0yI", "bLIawIQp3pk", "jHTpW7euAns", "M7q0Qbpa34U", "DuZWhRaLzhk", "lqUapRX9EsY", "isQPh9Gx0q4", "n0cUqNwYcoI", "Joed0P3hhbc", "RR31o8x1OvU", "rco9WLJ82u0", "3N84iZ68cXQ", "OvzMEwVnB2w", "VAIONzHzlXk", "ogELZ78OfyM", "KHvfwpnPwwU", "pRdT07TSSs0", "BO_XEpdw2jA", "ZCKw0nWkpfs", "XXW27KKHtc8", "onHJuyDjbsM", "Tfm-W_DSdXw", "EpDMsPgnh_M", "dTObKtHzroM", "7L8XvasJzdQ", "EXHjirjUJUk", "KcZPIfIbG5o", "0SEHUqkbIjU", "a_oAkbzSKxo", "WAtxEpMDeNk", "oZLNQl0bk1c", "_rGvb2yYh1M", "nz6NxH3wy94", "ToQT_i4I6vI", "ANsipsS7IK8", "T5YsZLJ5FjY", "uUVye2mdwew", "QgOpSFyin8M", "mgWEIiIfGsQ", "z4lVylO7y5U", "TU3nNaIkQLQ", "9_wvQGdCF94", "u2HUXZ61EY8", "78GFp2zTPoo", "6DA92d93FRI", "ke418cAUcPs", "ympVA0GW1jE", "6RSXQsYYso4", "D5Y7R7-4FnA", "wOedgb2zC5s", "slwqiGh0Fak", "nHJWcFe27S0", "EIQkBlo1L8k", "uK3BbETDYis", "_C7bJiFTfFs", "q8AP5XYs8jg", "Zhz9g6A_fuI", "Chu4mvEUc5I", "U__RaOy39Sg", "i7g-TvczpSw", "rbf_NX0-Uj0", "mAyTv64YkTI", "va7PBIQ4CJ8", "Um2Me3Iuv5Q", "nmL-fwtjVUA", "GD0JbDyGOsA", "MK83CkvLbcQ", "i_xZSTF_Uq0", "kSZuVW_1yi8", "cNHY90uQ2eY", "iqsAjzm-qtA", "oPiCgf4U6oE", "hnj8gGf2e7E", "NQjH3-6Qm7c", "o5BRy93769U", "1D_vCWzX_Rw", "5kWBZz7dFxw", "SUfOQ5XeS5Q", "nDgC8JOQhiM", "AMyaeLu-vk0", "PtdiO1ZiiXk", "DYBvijAJ6is", "lZ5hfrCz4xk", "wh6hX21jDzE", "nnIdDkiAMnE", "rg9k12aTR5o", "-4KJIzxbt8Y", "3yi75YlpiT0", "pji33MoJ5Z4", "IkPxOG3Ifzs", "aIqRimZ7BVw", "2_9x9iiJ_Z0", "PIN5RE53q-k", "91j3Td52XRo", "gMT-lfeNzTw", "pAfYOGTbbyU", "YhR4klyAqP4", "yorlFRAyw1A", "nJu_-Iuppc0", "bX-6LFPSQuk", "O74Q1VTz4j4", "byYGPO4ptxs", "Is7qSijW-3s", "O9L9yXswSxI", "CGsyVoteOOg", "M3kLUJd4EoA", "yHhO7Qx-D_Y", "9G9oGQ-PbqM", "dYAKLa3CETk", "wf3RSYU2GSg", "l2LvDHobpNc", "VNWSx6v4vxg", "AsxPX5fXlFo", "EyFop7vyAjc", "J6y-_dhHlHA", "lpI2GoHtU9c", "PIVkD8x6qNw", "agq42yz2ACg", "7FTvYN18eUU", "Y-lE4Tz2I_Y", "Br1HR-LUgXg", "ve3OM1X2hDg", "4YI3zlxfjNk", "QRO5wzAaT00", "GIwCGk-ABNQ", "vfQthafhT-U", "CUmLf-Wsr0o", "QGgX8H9vWLo", "UBAFthdYbgw", "ByO3K59qxSI", "tnQC0YZgyTo", "cyK6ADLZBAA", "0QdZlwigQsU", "NaAHZpqSQY0", "AJur6roKktc", "t2l4PVJkhzQ", "OeEXQlQMH2E", "HhlkxBQdXMM", "3yXCUpzCOF0", "RV8bPx_n4zU", "V0hIO-xoaxc", "SEpWpD0NlPE", "aWL9yDjk3GQ", "28-lrKkRUvU", "UlNkQJzw4oA", "iGzTUBntPa8", "aPFGf_DJvDI", "-W8N06QqK8A", "7eOt2mHEAOM", "DFbhGu6Lmeg", "kHFhoDcc4z4", "z_CFkhExRSI", "nwgwCmh7SGg", "3PA2jYe0HOA", "w-bndzHmMfg", "cPOwyAJ3DG8", "F_38TFES88I", "W--bw7vU6_g", "YS_QhzhLxp8", "BRgHgok9bwk", "dleQ_bcbMJo", "2ze5S4lZbkU", "kbeD1shCNYA", "oxfUmcMzx08", "yLhfsefdhQc", "cCay5ek_cW0", "3OjnPW6QkIA", "CTLY4b3sG9E", "Z1bv_EK7cZM", "KIkrc2Nv-Bo", "TXyvOD4dgeU", "dlhr4hqIczY", "oeknIl3MJv8", "9PR3eyNTLbk", "QOTjkZQNkWk", "XqsAFdFsQmQ&t=6s", "2QHVyxQbh34", "XA3Itg3HHag", "xVtHiX12TVw", "tMPzhhohExk", "v5RNVbxR78E", "0TpzMDOEJFM", "pNIWOHcZkZM", "FjIbuwNDpDo", "aoWUD8GvZ8k", "AxkQzj7M8Gw", "dJ0ChDF7CIU", "D15QH72xfPA", "iwEvOrNhJQQ", "Rej2rmTDnCQ", "V1dPbQZvtdg", "f6_SdYFDgt0", "Avn7ABVHPYk", "CKgq57TBHro", "gvQsyY5lTLM", "CrL5tqFczPE", "Mbh4xd2V6RI", "ZsX58_BvRAs", "LgU4gxpPjF0", "YREflbQzVB4", "rHfcIJUL160", "9VcIMVPIfRk", "oS56i5mjW-Q", "TICY1LdiwO4", "_BOEs7iaX-M", "vaF4T-1mbgc", "XuEzkKsg5DY", "PF39Te4rp1c", "S6tu8ipL_YA", "uQTHvlHfoEY", "JtTneV8SaB0", "SpVOTEOMRuE", "7YkkEKSpJAs", "Ay8UQDS5rPY", "x301B6Mf3Fk", "tTZs5xoySIg", "xFgCaX1DIRg", "TRozAbaKs9M", "LyXTnJQ-vPI", "ZVQTt4CgNZs", "RkdJti43IgU", "xF8BfhIUDos", "WRve0s4iWzI", "vBgcTJ9Z4Qc", "STPFgMxjYe8", "dlKoJSztH1E", "Jv5j8klfbK8", "c1MMT08A9kY", "UcEnYRa74zM", "iZ-IibQlIW4", "dLXA5OAFZx0", "sJ9ZGgLkfJo", "sZmeXQq8mXo", "o0IYq8AhMJc", "s5jzHw3lXCQ", "kJ1_P5oqf6Y", "ejcPaNcMQ9o", "Gflpf0DrCgw", "x0HzNIa1akc", "N7f71hadNbE", "c5QwTB_6IP4", "9ritLevsP68", "TkRzBUfWne8", "MhwvRQpYquU", "1uEYveSssok", "vZikLJ24YrA", "uOO8yA2eU7M", "dG8mNFz0Uas", "Vw41NZYiALg", "wXEY5vg75EY", "lVReDgGmQkA", "IuUkweUI1DY", "wrd5r1TzkCM", "0GwbSvMIKVg", "cECT_90pgyc", "ww_Mo5HQ8-c", "q1rYhO--TDA", "-hyOB9KBgGg", "vgvCxL7dMJk", "tPXqTQsk5o4", "jul--iFjZo0", "HSOQSnSUlp8", "mGpMaShltbc", "98TxM0zAX0M", "B96ZxnDaNGM", "TJmQonKBmvQ", "4WuTaZ_J-YE", "-Bazy3Ew6D4", "n1m9W_KppZY", "q5hkOPKd9bw", "f5pV1dOlrw0", "YdP0PJ5_yeo", "qA6odz9GmJY", "z0ksMcD9ibc", "uVvEkcN5tW8", "O_UZ2OmARg4", "GfWBbf40o-A", "-aVrzSGgkto", "lod_LUp3ggc", "kypQF72MhJY", "jL-tFPceWBY", "1eFbIHCaXBw", "jXoS_HB1I3o", "j7ah3RA0Alo", "GhESSMvf_to", "9v110OJRzfE", "lvn3_CNVSFs", "3MEHWuXhcHA", "Oo9V2Tv4yOs", "TSfTRBm5_Vk", "-nPY7cLu0S4", "WeCGTosv-_c", "D-On0DGcDlc", "bXTQokbSdKo", "cXK2yh5eNTU", "hAMhr66juP4", "Xh-MLiVCjc0", "lJaca6MgrA0", "7PMoWLXDcac", "Jtldo0wQ3WA", "pU2sCCdlx_I", "ZtCwlCg5t7s", "JolUAwUBa0U", "Sm_Qqwerlss", "Gy5Wh3oLWNA", "6gbvUAU-GoM"]
download_clips(videos, None, dry=True, limit=1)
